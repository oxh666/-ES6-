# -ES6-

不定时更新

## 第一天

### 查看node.js不同版本已实现ES6特性的指令 ==> $ node --v8-options | grep harmony



### let命令

###### 用来声明变量，仅在let所在的代码块中生效（局部） ---作用：减少运行时错误，防止在变量声明前就使用这个变量， 从而导致意料之外的行为

2.1  不存在变量提升，在声明前使用，会报错 `//ReferenceError`

2.2  暂时性死区，在代码块中，使用LET命令声明变量之前，该变量是不可用的简称TDZ（暂时性死区），即便有一个全局同名变量

2.3  不允许重复声明，


## 第二天

### 块级作用域

ES5只有全局作用域和函数作用域，有很多不合理的场景

场景一：内层变量可能会覆盖外层变量

场景二：用来计数的循环变量泄露为全局变量



### ES6作用域

​	let实际上为JS新增了块级作用域

​	ES6允许块级作用域的任意嵌套，但是外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量



### 块级作用域与函数声明

ES5 规定， 函数只能在顶层作用域和函数作用域之中声明， 不能在块级作用域声明

ES6 引入了块级作用域， 明确允许在块级作用域之中声明函数。 ES6 规定， 块级作用域之中， 函数声明语句的行为类似于 let ， 在块级作用域之外不可引用。

1. 允许在块级作用域内声明函数。
2. 函数声明类似于 var ， 即会提升到全局作用域或函数作用域的头部。
3. 同时， 函数声明还会提升到所在的块级作用域的头部。

### do表达式

```js
let a = {
  let b = 1
}
```

a获取不到b的值,因为块级作用域不返回值

```js
let a = do {
    let b = 1
}
```

现在一个提案在块级作用域前加do,即可得到返回值（a可以获得b的值）



### const 命令

###### const 声明一个只读的常量。 一旦声明， 常量的值就不能改变

###### const 声明的变量不得改变值， 这意味着， const 一旦声明变量， 就必须立即初始化， 不能留到以后赋值

```js
const foo;
// SyntaxError: Missing initializer in const declaration
```

上面代码表示， 对于 `const` 来说， 只声明不赋值， 就会报错。

`const` 的作用域与 `let` 命令相同： 只在声明所在的块级作用域内有效。

`const` 命令声明的常量也是不提升， 同样存在暂时性死区， 只能在声明的位置后面使用

`const` 声明的常量， 也与 let 一样不可重复声明。

#### 本质

`const` 实际上保证的， 并不是变量的值不得改动， 而是变量指向的那个内存地址不得改动。 对于简单类型的数据（ 数值、 字符串、 布尔值） ， 值就保存在变量指向的那个内存地址， 因此等同于常量。 但对于复合类型的数据（ 主要是对象和数组） ， 变量指向的内存地址， 保存的只是一个指针， const 只能保证这个指针是固定的， 至于它指向的数据结构是不是可变的， 就完全不能控制了。 因此， 将一个对象声明为常量必须非常小心

### 顶层对象的属性

顶层对象， 在浏览器环境指的是 window 对象， 在Node指的是 global 对象。

ES5之中， 顶层对象的属性与全局变量是等价的

从ES6开始， 全局变量将逐步与顶层对象的属性脱钩

```js
var a = 1;
// 如果在Node的REPL环境， 可以写成global.a
// 或者采用通用方法， 写成this.a
window.a // 1
let b = 1;
window.b // undefined
```

上面代码中， 全局变量 a 由 var 命令声明， 所以它是顶层对象的属性； 全局变
量 b 由 let 命令声明， 所以它不是顶层对象的属性， 返回 undefined 。

### global 对象



## 第三天



### 变量的解构赋值

#### 数组的解构赋值

以前， 为变量赋值， 只能直接指定值。

```js
let a = 1;
let b = 2;
let c = 3;
```

ES6 允许写成下面这样。

```js
let [a, b, c] = [1, 2, 3]
```

本质上， 这种写法属于“模式匹配”， 只要等号两边的模式相同， 左边的变量就会被赋予对应的值。

#### 默认值

##### 解构赋值允许指定默认值

```js
let [foo = true] = [];
foo // true
let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```

注意， ES6 内部使用严格相等运算符（ === ） ， 判断一个位置是否有值。 所以，如果一个数组成员不严格等于 undefined ， 默认值是不会生效的。

```js
let [x = 1] = [undefined];
x // 1
let [x = 1] = [null];
x // null
```

上面代码中， 如果一个数组成员是 `null` ， 默认值就不会生效， ***因为 `null` 不严格等于 `undefined` 。***

##### 默认值是一个表达式

那么这个表达式是惰性求值的， 即只有在用到的时候，才会求值。

```js
function f() {
console.log('aaa');
} l
et [x = f()] = [1];
```

上面代码中， 因为 x 能取到值， 所以函数 f 根本不会执行。 上面的代码其实等价
于下面的代码

##### 默认值可以引用解构赋值的其他变量， 但该变量必须已经声明。

```js
let [x = 1, y = x] = []; // x=1; y=1
let [x = 1, y = x] = [2]; // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = []; // ReferenceError
```

上面最后一个表达式之所以会报错， 是因为 x 用到默认值 y 时， y 还没有声明



#### 对象的解构赋值

对象的解构赋值是下面形式的简写

```js
let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
```

也就是说， 对象的解构赋值的内部机制， 是先找到同名属性， 然后再赋给对应的变
量。 真正被赋值的是后者， 而不是前者。

```js
let { foo: baz } = { foo: "aaa", bar: "bbb" };
baz // "aaa"
foo // error: foo is not defined
```

上面代码中， `foo` 是匹配的模式， `baz` 才是变量。 真正被赋值的是变量 `baz` ，而不是模式 `foo` 。

下面是嵌套赋值的例子。

```js
let obj = {};
let arr = [];
({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });
obj // {prop:123}
arr // [true]
```

##### 对象的解构也可以指定默认值。

默认值生效的条件是， `对象的属性值严格等于 undefined` 。

```js
var {x = 3} = {x: undefined};
x // 3
var {x = 3} = {x: null};
x // null
```

上面代码中， 如果 **x 属性等于 null ， 就不严格相等于 undefined ， 导致默认值不会生效。**

### 数值和布尔值的解构赋值

只要等号右边的值不是对象或数组， 就先将其转为对象。 由于 undefined 和 null 无法转为对象， 所以对它们进行解构赋值， 都会报错

```js
let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
```

### 函数参数的解构赋值

### 用途

#### 1.交换变量的值

```js
let x = 1;
let y = 2;
[x, y] = [y, x];
```

#### 2.从函数返回多个值

函数只能返回一个值， 如果要返回多个值， 只能将它们放在数组或对象里返回。 有
了解构赋值， 取出这些值就非常方便。

```js
// 返回一个数组
function example() {
return [1, 2, 3];
} l
et [a, b, c] = example();
// 返回一个对象
function example() {
return {
foo: 1,
bar: 2
};
} l
et { foo, bar } = example();
```

#### 3.函数参数的定义

#### 4.提取JSON数据,可以提取JSON对象中的数据

#### 5.函数参数的默认值

#### 6.遍历Map结构

```js
var map = new Map();
map.set('first', 'hello');
map.set('second', 'world');
for (let [key, value] of map) {
console.log(key + " is " + value);
} /
/ first is hello
// second is world
```

如果只想获取键名， 或者只想获取键值， 可以写成下面这样。

```
// 获取键名
for (let [key] of map) {
// ...
} /
/ 获取键值
for (let [,value] of map) {
// ...
}
```

#### 7.输入模块的指定方法

加载模块时， 往往需要指定输入哪些方法。 解构赋值使得输入语句非常清晰。

```js
const { SourceMapConsumer, SourceNode } = require("source-map");
```



### 字符串的扩展

记录 P63-P81 暂无

#### 标签模版

```js
alert`123`
// 等同于
alert(123)
```

标签模板其实不是模板， 而是函数调用的一种特殊形式。 “标签”指的就是函数， 紧
跟在后面的模板字符串就是它的参数

```js
var a = 5;
var b = 10;
tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag(['Hello ', ' world ', ''], 15, 50);
```

tag函数
